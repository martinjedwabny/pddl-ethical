<html>
<head>
<title>HSP* Homepage</title>
</head>
<body>
<p>
<center><h1>HSP<sup>*</sup></h1></center>
<p align="center">By <a href="http://www.ida.liu.se/~pahas/">P@trik Haslum</a>
and <a href="http://www.ldc.usb.ve/~hector/">Hector Geffner</a>.

<p>Please send questions, comments, bug reports, etc. to
<a href="mailto:pahas@ida.liu.se">pahas@ida.liu.se</a>.

<p>HSP<sup>*</sup> is a family of domain-independent (mostly-STRIPS)
planners. Common to all family members is that they are based on
heuristic search, using a heuristic derived automatically from the
problem representation, and that they are all optimal <i>w.r.t.</i>
some measure.
<p>
The HSP<sup>*</sup> planners build on ideas from their non-optimal
predecessors, <a href="http://www.ldc.usb.ve/~hector/">HSP and HSPr</a>.

<p><h2><a name="variants">HSP<sup>*</sup> Variants</a></h2>
The HSP<sup>*</sup> family currently includes:
<dl>
<dt><b>hsp<sub>0</sub></b> (<i>a.k.a.</i> TP4)
<dd>Basic HSP<sup>*</sup> planner.
<br>The planner performs a regression search, guided by an admissible
heuristic called H<sup>2</sup>. The H<sup>2</sup> heuristic is defined
by approximating the cost of sets of (subgoal) atoms by the cost of the
most costly subset of size at most 2. It is computed (by a dynamic
programming method) and stored in a table before search begins.
<dt><b>hsp<sub>a</sub></b>
<dd>The H<sup>2</sup> heurstic can be viewed as the optimal cost in an
<i>approximate regression</i> search space. hsp<sub>a</sub> exploits this
by searching the approximate regression space for the analogously defined
H<sup><i>m</i></sup> heuristics, for <i>m &gt; 2</i>. During these searches,
it discovers (at least lower bounds on) the cost of some sets of (subgoal)
atoms of size m, and thus it computes parts of the H<sup><i>m</i></sup>
heuristics (which are in general more accurate than H<sup>2</sup>) as a side
effect. The resulting heuristic is used in a final (regression) search for
a plan.
<dt><b>hsp<sub>b</sub></b>
<dd>hsp<sub>b</sub> improves on the H<sup>2</sup> heuristic using
<i>boosting</i>: a series of short searches to solve, or find improved
lower bounds for, the atom sets stored in the heuristic table.
Using <i>conflict detection</i>, it may also add new atom sets to the
table (which are then boosted).
After boosting, it performs the same regression search as hsp<sub>0</sub>.
<dt><b>hsp<sub>c</sub></b>
<dd>hsp<sub>c</sub> uses an iterated combination of approximate regression
and boosting to improve the H<sup>2</sup> heuristic, and interleaves these
efforts with iterations of the search for a plan.
<dt><b>hsp<sub>d</sub></b>
<dd>hsp<sub>d</sub> is another variant of interleaving boosting to improve
the H<sup>2</sup> heuristic with plan search iterations. In difference to
hsp<sub>c</sub>, hsp<sub>d</sub> boosts only atom sets that were used in the
last search iteration.
</dl>
All HSP<sup>*</sup> planners are capable of performing several types of
planning. The supported types of planning and the associated options are:
<dl>
<dt><b>Parallel</b> (the default)
<dd>Generates parallel, non-temporal plans (<i>i.e.</i> graphplan style),
minimizing the number of steps.
<dt><b>Temporal</b> (option: <tt>-time</tt>)
<dd>Generates temporal plans, minimizing makespan. Constraints imposed
by reusable resources and atom locks (see <a href="#numeric">Numeric
Variables</a>) are respected.
<dt><b>Temporal with Resources</b> (options: <tt>-time -res</tt>)
<dd>Generates temporal plans, minimizing makespan, respecting both
reusable (including atom lock) and consumable resource constraints.
<dt><b>Sequential</b> (option: <tt>-seq</tt>)
<dd>Generates sequential plans, minimizing the number of actions.
<dt><b>Sequential with Cost</b> (options: <tt>-seq -cost</tt>)
<dd>Generates sequential plans, minimizing the sum of action costs
(action costs are derived from the problem <tt>:metric</tt> specification:
see <a href="#numeric">Numeric Variables</a>).
<dt><b>Sequential with Resources</b> (options: <tt>-seq -res</tt>)
<dd>Generates sequential plans minimizing number of actions, while
respecting consumable resource constraints.
<dt><b>Sequential with Cost and Resources</b>
 (options: <tt>-seq -cost -res</tt>)
<dd>Generates sequential plans minimizing sum of action costs and
respecting consumable resource constraints.
</dl>
For more options, see sections below.

<p>The TP4 temporal planner has participated in the
<a href="http://ipc.icaps-conference.org/">2002 &amp; 2004 International
Planning Competitions</a>, where it did not do exceedingly well.

<p><h2>Usage</h2>
The five planners are called <tt>hsp0</tt>, <tt>hsp_a</tt>, <tt>hsp_b</tt>,
<tt>hsp_c</tt> and <tt>d_hsp</tt>. General usage is,
<pre>
 hsp0 [planning type options] [other options] [input files...]
</pre>

<p>In addition, there are some utility programs: <tt>pddlcat</tt>, which
"cats" PDDL files and does some other possibly usefull things (including
<a href="redop.html">domain reduction</a>), <tt>rpgc</tt>, which generates
random propositional STRIPS problems, and <tt>chopshop</tt> which converts
MRCPS problems to PDDL.

<p><h3>Input</h3>
The planners accept domain and problem specifications in a PDDL2.1-like
language (see sections below, and [<a href="#ipc04">2</a>], for further
discussion of the differences).
Any number of input files can be given, and an input file can contain
several domain/problem specifications. All input is merged into a single
problem instance.

<p><b>Durative Actions</b>
Although the input language accepted by the HSP<sup>*</sup> planner looks
like PDDL2.1, it does not follow PDDL2.1 level 3 (durative action) semantics.
Instead the planners assume, like TGP, an "interval semantics" of durative
actions. For an action <i>A</i> executed over the interval <i>[S,T]</i>
(where <i>T = S+dur(A)</i>), it is assumed that
<ul>
<li>all preconditions of <i>A</i> must hold at <i>S</i>,
<li>persistent preconditions (<i>i.e.</i> those not deleted by the
action) must hold throughout the interval <i>[S,T]</i>,
<li>all effects, whether additions or deletions, take place at some,
not exactly known, point in the interior of the interval <i>[S,T]</i>.
</ul>
This implies that the execution of two actions can not overlap in time
if they are "mutex", by the standard definition (<i>i.e.</i> one deletes
a precondition or effect of the other). It also means that an action
that adds and deletes the same proposition is inconsistent (except in
certain cases, which are interpreted specially: see below).

<p>Note that action durations are <i>required to be &gt; 0</i>. The
planners accept actions with zero duration (mainly because instantiated
problem specifications tend to contain some "useless" actions, <i>e.g.</i>
<tt>(move X Y Y)</tt>, with zero duration and these are filtered out by
preprocessing), but may behave incorrectly in their presence.

<p><b><a name="numeric">Numeric Variables</a></b>
Numeric variables (<i>i.e.</i> non-constant functions in the problem
specification) and action conditions/effects on them are treated as
<i>resources</i> or <i>cost</i>. A resource is called <i>reusable</i>
iff it is only borrowed (not consumed or produced by any action), and
<i>consumable</i> otherwise. Consumable resources are restricted to be
decreasing only.

<p>Resources are identified by certain "patters" in action
conditions/effects:
<ul>
<li>An action that has the effects

<p><tt>(at start (decrease (&lt;fun&gt; ...) &lt;amount&gt;))</tt>
<br><tt>(at end  (increase (&lt;fun&gt; ...) &lt;amount&gt;))</tt>

<p>is said to "borrow" <tt>&lt;amount&gt;</tt> of the resource specified by
<tt>(&lt;fun&gt; ...)</tt>. According to the strict definition of borrowing,
the action should also have a precondition <tt>(&lt;fun&gt; ...) &gt;=
 &lt;amount&gt;</tt>, but this can left out (in which case it is considered
implicit).

<li>Similarly, an action that has the precondition

<p><tt>(at start (&lt;pred&gt; ...))</tt>

<p>and the effects

<p><tt>(at start (not (&lt;pred&gt; ...)))</tt>
<br><tt>(at end  (&lt;pred&gt; ...))</tt>

<p>is said to "lock" the atom specified by <tt>(&lt;pred&gt; ...)</tt>.
This means the atom will be treated as a reusable resource with unit
capacity.
</ul>

<p>If the problem specifies a <tt>:metric</tt> (other than <tt>total-time</tt>)
a <i>cost</i> for each action is calculated as the actions net effect on the
metric expression. Cost is always minimized: if the <tt>:metric</tt> expression
specifies <tt>maximize</tt> the expression is multiplied by -1.

<p>Action costs are <i>required to be &gt; 0</i>. As with durations, the
planners accept actions with zero cost, but may behave incorrectly in their
presence.

<p><b>DKEL Support</b>
Input files may also contain domain knowledge items specified in DKEL
syntax (see [<a href="#dkel02">5</a>]).
There are some restriction on the accepted items:
<ul>
<li>Only <tt>:invariant</tt> and <tt>:irrelevant</tt> items are allowed.
<li><tt>:invariant</tt> items can only contain <tt>:set-constraint</tt>s.
The set constraint can contain positive and negated atoms, <tt>setof</tt>
expressions, but not equalities (this also applies to the contents of
<tt>setof</tt> expressions). <tt>at-least</tt> constraints are accepted,
but will be mostly ignored.
<li><tt>:irrelevant</tt> items can only contain <tt>:action</tt> elements.
<li>The <tt>:context</tt> of an item or <tt>setof</tt> expression is
restricted to be a single literal or a conjunction, and may only contain
static predicates (including equality).
</ul>

<p><b>Misc. Features and Restrictions</b>
<ul>
<li>Typing is supported, including type hierarchies but not
<tt>either</tt>-types.
<li>Equality, negative preconditions and negative goals are allowed.
<li>Predicates, functions, types, objects and actions all exist in the same
"namespace", which means the same name can not be used for different kinds
of things. Note also that <tt>object</tt> is reserved as the name of the top
domain of the type heirarchy (some domains specifications seem to demand this).
<li>No difference is made between durative and non-durative actions.
Actions can be declared with either <tt>:action</tt> or
<tt>:durative-action</tt>: the <tt>:duration</tt> specifier and
timing keywords for preconditions and effects are accepted regardless.
<li>Action duration specification can be simplified to

<p>&nbsp;<tt>:duration&nbsp;&lt;expression&gt;</tt>

<p>where <tt>&lt;expression&gt;</tt> may contain constants, functions
(of the action arguments) and the arithmetic operators. Functions
appearing in <tt>:duration</tt> specifications must be static,
<i>i.e.</i> not modified by any action.
</ul>

<p><a name="optcommon"><h3>Common Options</h3></a>
<dl>
<dt><b>Planning Type Options:</b>
<dd>(see <a href="#variants">HSP<sup>*</sup> Variants</a> above)
 <dt><tt>-time</tt>
 <dd>Temporal planning.
 <dt><tt>-res</tt>
 <dd>Resource-Constrained planning.
 <dt><tt>-seq</tt>
 <dd>Sequential planning.
 <dt><tt>-cost</tt>
 <dd>Optimal-Cost planning (using problem <tt>:metric</tt>).

<dt><b>Preprocessing Options:</b>
<dd>Standard preprocessing detects static atoms and actions (by simple
 reachability analysis) and removes them from the problem.
 <dt><tt>-no-prep</tt>
 <dd>Disable standard preprocessing.
 <dt><tt>-rm</tt>
 <dd>Detect and remove irrelevant atoms, using standard reverse reachability.
 <dt><tt>-use-strict-borrow</tt>
 <dd>Use the strict definition of "borrow" (with explicit precondition) when
  identifying reusable resources.
 <dt><tt>-use-extended-borrow</tt>
 <dd>Use the extended definition of "borrow" when identifying reusable
  resources. This is needed to find such resources in some domains,
  <i>e.g.</i> the UMTS domain.

<dt><b>Heuristic Options:</b>
 <dd>The default base heuristic is H<sup>2</sup>.
 <dt><tt>-1</tt>
 <dd>Use H<sup>1</sup> as base heuristic.
 <dt><tt>-load</tt>
 <dd>Read heuristic table from input file(s).

<dt><b>Search Options:</b>
<dd>The default search algorithm is IDA<sup>*</sup>, without transposition
table or cycle check.
 <dt><tt>-tt</tt>
 <dd>Enable transposition table (applies only to IDA<sup>*</sup>).
 <dt><tt>-cc</tt>
 <dd>Enable cycle checking (applies to IDA<sup>*</sup> and branch-and-bound).
 <dt><tt>-cut</tt> / <tt>-no-cut</tt>
 <dd>Enable/Disable pruning techniques (right-shift cuts in parallel/temporal
  planning, commutativity cuts in sequential). Cuts are enabled by default
  with IDA<sup>*</sup> and branch-and-bound, and disabled by with
  A<sup>*</sup>.
 <dt><tt>-bfs</tt>
 <dd>Use best-first search (A<sup>*</sup>).
 <dt><tt>-px &lt;threshold&gt;</tt>
 <dd>Use partial expansion A<sup>*</sup> search, with the specified threshold
  (0 is usually a good threshold value).
 <dt><tt>-bb &lt;initial bound&gt;</tt>
 <dd>Use DFS branch-and-bound, with the specified initial upper bound.

<dt><b>Limit Options:</b>
 <dt><tt>-t &lt;seconds&gt;</tt>
 <dd>Set a CPU time limit.

<dt><b>Printing Options:</b>
 <dt><tt>-v &lt;n&gt;</tt>
 <dd>Set verbose level (<tt>&lt;n&gt; = 0 .. 4</tt>). Default is approximately
  1.
 <dt><tt>-strict-ipc</tt>
 <dd>Output plan in IPC format (with strict epsilon separation between
  actions to ensure that the plan is valid according to PDDL2.1 semantics).
  Note that epsilons are not included in the makespan, and thus not
  minimized. This option is only supported by <tt>hsp0</tt> and
  <tt>hsp_a</tt>.
 <dt><tt>-pddl</tt>
 <dd>Output plan in PDDL format (a format that can be read and validated
  with <tt>pddlcat</tt>).
 <dt><tt>-no-plan</tt>
 <dd>Don't print the plan.
</dl>

<p><a name="opthsp0"><h3><tt>hsp0</tt></h3></a>
<dl>
 <dt><tt>-post</tt>
 <dd>Use two-stage optimization (see [<a href="#ipc04">2</a>] for a
  description). This applies only to temporal planning, and is (possibly)
  usefull only when actions have non-integer durations.
 <dt><tt>-all</tt>
 <dd>Find (and print) all optimal plans.
</dl>
In addition to the above, <tt>hsp0</tt> also has a lot of extra debug and
test options. For a full list, see the source code :)

<p><a name="opthspa"><h3><tt>hsp_a</tt></h3></a>
By default, <tt>hsp_a</tt> performs <i>m</i>-approximate searches for
<i>m = 3,4,...</i> until either a non-approximate solution is found, or
the <i>m+1</i>-approximate solution cost is the same as the
<i>m</i>-approximate solution cost. A fixed limit on <i>m</i> can be
set using the <tt>-m</tt> option (<i>3 - 4</i> are usually good values).
Approximate regression searches are made using IDAO<sup>*</sup>, an
extension of IDA<sup>*</sup> to AND/OR-graphs, but alternative search
algorithms can be chosen.
<dl>
 <dt><tt>-m &lt;m&gt;</tt>
 <dd>Limit approximate searches to max <tt>&lt;m&gt;</tt>.
 <dt><tt>-itest</tt>
 <dd>Use Iterative Test instead of IDAO<sup>*</sup>.
 <dt><tt>-mm</tt>
 <dd>Use mini-max instead of IDAO<sup>*</sup>.
 <dt><tt>-no-alpha</tt>
 <dd>Disable the "alpha cut" in IDAO, meaning all successors to an
  AND-node are searched. This increases the amount of information gained
  during the search slightly, but at a rather large computational cost.
  It is usually not worth the price.
 <dt><tt>-save</tt>
 <dd>Write heuristic to <tt>h.pddl</tt> after approximate regression
  searches are finished.
 <dt><tt>-post</tt>
 <dd>Use two-stage optimization (as described for
  <a href="#hsp0"><tt>hsp0</tt></a> above).
</dl>

<p><a name="opthspb"><h3><tt>hsp_b</tt></h3></a>
<tt>hsp_b</tt> performs boosting searches for entries in the heuristic table
(<i>i.e.</i> sets of atoms) in order of increasing estimated cost. The
boosting search for an entry ends when a solution is found (then the optimal
cost of the atom set becomes known) or when its estimated cost has increased
so that it is no longer the least costly entry in the table. The boosting
process ends when the next entry to boost has an estimated cost greater than
that of the problem goals. When entries are solved, new entries may be added
to the table by conflict detection: the new entries consist of the just solved
atom set plus one atom that is deleted by the plan found for the solved set.
<dl>
 <dt><tt>-cd &lt;n&gt;</tt>
 <dd>Limit size of atom sets added by conflict detection to <tt>&lt;n&gt;</tt>
  (<i>3</i> is usually a good value). By default, there is no limit, and this
  can lead to unnecessarily large sets being added to the heuristic table.
 <dt><tt>-no-cd</tt>
 <dd>Disable conflict detection (thus, only atoms sets computed by base
  heuristic are boosted).
 <dt><tt>-f</tt>
 <dd>Fix boosting limit at initially estimated goal cost.
 <dt><tt>-wps &lt;w&gt;</tt>
 <dd>Limit the amount of "work" per boosting search to <tt>&lt;w&gt;</tt>.
  "Work" is measured by number of heuristic evaluation (which is roughly
  linearly related to time).
 <dt><tt>-save</tt>
 <dd>Write heuristic to <tt>h.pddl</tt> after boosting is finished.
</dl>

<p><a name="opthspc"><h3><tt>hsp_c</tt></h3></a>
<tt>hsp_c</tt> combines approximate searches and boosting in an iterative
way. In each iteration, a single IDA<sup>*</sup> iteration is performed to
check if there is a solution within the current bound. If not, a cost-bounded
<i>m</i>-approximate search is made, followed by a fixed-limit boost without
conflict detection. <i>m</i> is initially <i>3</i> and is incremented when
the <i>m</i>-approximate search finds a solution.
<dl>
 <dt><tt>-m &lt;m&gt;</tt>
 <dd>Limit approximate searches to <tt>&lt;m&gt;</tt>.
 <dt><tt>-itest</tt>
 <dd>Use Iterative Test instead of IDAO<sup>*</sup>.
 <dt><tt>-no-boost</tt>
 <dd>Disable boosting.
 <dt><tt>-no-init-boost</tt>
 <dd>Disable initial boosting. (Normally, a round of boosting is performed
  before the first iteration.)
 <dt><tt>-save</tt>
 <dd>Write heuristic to <tt>h.pddl</tt> after plan found or search
  interrupted.
</dl>

<p><a name="opthspd"><h3><tt>d_hsp</tt></h3></a>
<tt>d_hsp</tt> alternates between IDA<sup>*</sup> iterations and fixed-limit
boosts (by default with conflict detection, but this can be limited or
disabled). However, only table entries that were used to evaluate a state
encountered in the preceeding IDA<sup>*</sup> iteration are boosted.
<dl>
 <dt><tt>-cd &lt;n&gt;</tt>
 <dd>Limit size of atom sets added by conflict detection to <tt>&lt;n&gt;</tt>.
 <dt><tt>-no-cd</tt>
 <dd>Disable conflict detection alltogether.
 <dt><tt>-dwps</tt>
 <dd>Dynamically calculate a limit on the amount of "work" per boosting
  search (based on the amount of work spent in last search iteration).
 <dt><tt>-wps &lt;w&gt;</tt>
 <dd>Limit the amount of "work" per boosting search to <tt>&lt;w&gt;</tt>.
 <dt><tt>-save</tt>
 <dd>Write heuristic to <tt>h.pddl</tt> after plan found or search
  interrupted.
</dl>

<p><a name="optipc"><h3>IPC Settings</h3></a>
The following options should (approximately) reproduce the results of
(temporal) hsp<sub>0</sub> and hsp<sub>a</sub> from the 2004 planning
competition:
<pre>
 hsp0 -time -rm -use-extended-borrow -strict-ipc &lt;domain&gt; &lt;problem&gt;
 hsp_a -time -rm -use-extended-borrow -strict-ipc -m 3 &lt;domain&gt; &lt;problem&gt;
</pre>
For the <tt>satellite</tt> domain, a different setting was used:
<pre>
 hsp0 -time -rm -use-extended-borrow -strict-ipc -post -cc &lt;domain&gt; &lt;problem&gt;
 hsp_a -time -rm -use-extended-borrow -strict-ipc -m 3 -post -cc &lt;domain&gt; &lt;problem&gt;
</pre>
Note that the planners can not handle timed initial litterals, nor (due to
the different interpretation of durative actions) the compiled versions of
such domains.

<p><h2>Downloading and Compiling</h2>
<ul>
<li>Source tarball: <a href="hsps.tar.gz">hsps.tar.gz</a>.
<li>Domains, problems and scripts for experiments reported in the
ECP'01 paper [<a href="#pub01">1</a>] are in a separate archive:
<a href="ecp01_exp.tar.gz">ecp01_exp.tar.gz</a>. The MRCPS problems,
sets
<a href="ftp://ftp.bwl.uni-kiel.de/pub/operations-research/progen/j12.mm.tgz">J12</a>,
<a href="ftp://ftp.bwl.uni-kiel.de/pub/operations-research/progen/j14.mm.tgz">J14</a> and
<a href="ftp://ftp.bwl.uni-kiel.de/pub/operations-research/progen/j16.mm.tgz">J16</a>,
are not included in the archive, but are available from
<a href="http://www.bwl.uni-kiel.de/Prod/psplib/data.html">PSPLib</a>,
and can be converted using the <tt>chopshop</tt> program.
</ul>

<ul>
<li>HSP<sup>*</sup> has been developed using <tt>g++ 3.2</tt>. Whether it
will compile using any other compiler is not known.
<li>To compile the parser requires <tt>bison++/flex++</tt>. Last I checked,
these can be fetched from
<a href="ftp://ftp.th-darmstadt.de/pub/programming/languages/C++/tools/flex++bison++/">ftp://ftp.th-darmstadt.de/pub/programming/languages/C++/tools/flex++bison++/</a>.
Note that this is <em>not</em> the standard GNU <tt>bison</tt> or
<tt>flex</tt>.
<li>For convenience, pregenereated parser and scanner files are included in
the source archive. To use them, copy <tt>{grammar,scanner}.pregen.{h,cc}</tt>
to the corresponding name without "<tt>.pregen</tt>". However, these files
were generated on a solaris machine, and may not work on all platforms.
<li>Compilation settings and compile-time options are set by editing the
<tt>makedefs</tt> and <tt>config.h</tt> files. For most non-esotheric
platforms, the default settings should be adequate.
</ul>

<p><h2>Publications</h2>
The following papers describe work on or related to the HSP<sup>*</sup>
planners.
<dl>
<dt>[<a name="pub04">1</a>] P. Haslum
<a href="http://www.ida.liu.se/~pahas/public/postimp.ps.gz">Improving
Heuristics Through Search</a>. European Conference on Artificial
Intelligence, 2004 (short paper).
<dt>[<a name="ipc04">2</a>] P. Haslum
<a href="http://www.ida.liu.se/~pahas/public/tp404.ps.gz">TP4'04 and
<tt>hsp<sup>*</sup><sub>a</sub></tt></a>. In 3rd IPC systems descriptions
booklet (available as a whole from <a href="http://ipc.icaps-conference.org">
http://ipc.icaps-conference.org</a>).
<dt>[<a name="pub01">3</a>] P. Haslum &amp; H. Geffner,
<a href="http://www.ida.liu.se/~pahas/public/draft03.ps.gz">Heuristic
Planning with Time and Resources</a>. European Conference on Planning,
2001.
<dt>[<a name="pub00">4</a>] P. Haslum &amp; H. Geffner,
<a href="http://www.ida.liu.se/~pahas/public/admissible.ps.gz">Admissible
Heuristics for Optimal Planning</a>. Proc. International Conference on
AI Planning and Scheduling, 2000.
<dt>[<a name="dkel02">5</a>] P. Haslum &amp; U. Scholz
<a href="http://www.ida.liu.se/~pahas/public/dkel.ps.gz">Domain Knowledge
in Planning: Representation and Use</a>. ICAPS Workshop on PDDL, 2003.
</dl>

<p align="right">
/P@trik Haslum, July 2004
</body>
</html>
